class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(1, n + 1):
            if s[i - 1] != '0':
                dp[i] += dp[i - 1]
            if i > 1 and s[i - 2] != '0' and (int(s[i - 2]) * 10 + int(s[i - 1]) <= 26):
                dp[i] += dp[i - 2]
        return dp[n]
'''
动态规划法。

假设 dp[i] 表示字符串 s 的前 i 个字符 s[1..i] 的解码方法数。

考虑最后一次解码中使用了 s 中的哪些字符：

第一种情况是我们使用了一个字符，即 s[i] 进行解码，那么只要 s[i]≠0，它就可以被解码成 A∼I 中的某个字母。由于剩余的前 i-1 个字符的解码方法数为 dp[i-1]，所以 dp[i] = dp[i-1]。
第二种情况是我们使用了两个字符，即 s[i-1] 和 s[i] 进行编码。与第一种情况类似，s[i-1] 不能等于 0，并且 s[i-1] 和 s[i] 组成的整数必须小于等于 26，这样它们就可以被解码成 J∼Z 中的某个字母。由于剩余的前 i-2 个字符的解码方法数为 dp[i-2]，所以 dp[i] = dp[i-2]。
将上面的两种状态转移方程在对应的条件满足时进行累加，即可得到 dp[i]的值。在动态规划完成后，最终的答案即为 dp[n]。

由于 dp[i] 的值仅与 dp[i-1] 和 dp[i-2] 有关，因此可以不定义 dp 数组，可以仅使用三个变量进行状态转移。

简单概述就是考虑两种情况一次取一位和一次取两位，分两种情况一次累加
'''